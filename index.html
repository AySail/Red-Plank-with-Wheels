<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Red Plank with Wheels</title>
  <style>
    body, html {
      margin: 0; 
      padding: 0; 
      overflow: hidden;
      height: 100%;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>

  <!-- Import Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <!-- Import OrbitControls(Not used but there if you want to add more -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.min.js"></script>
</head>
<body>
<script>
  // Scene and camera
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
  );
  camera.position.set(0, 5, 10);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Load ground texture
  const textureLoader = new THREE.TextureLoader();
  const roadTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');

  roadTexture.wrapS = THREE.RepeatWrapping;
  roadTexture.wrapT = THREE.RepeatWrapping;
  roadTexture.repeat.set(10, 10);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(100, 100);
  const groundMat = new THREE.MeshPhongMaterial({ map: roadTexture });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(5, 10, 7);
  scene.add(dirLight);

  // Car
  const car = new THREE.Group();

  // Car body
  const bodyGeo = new THREE.BoxGeometry(2, 0.5, 4);
  const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.5;
  car.add(body);

  // Wheels (cylinders)
  const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
  const wheelMat = new THREE.MeshPhongMaterial({ color: 0x333333 });

  function makeWheel(x, z) {
    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
    wheel.rotation.z = Math.PI / 2;
    wheel.position.set(x, 0.2, z);
    return wheel;
  }

  car.add(makeWheel(-0.9, 1.5));  // front-left
  car.add(makeWheel(0.9, 1.5));   // front-right
  car.add(makeWheel(-0.9, -1.5)); // back-left
  car.add(makeWheel(0.9, -1.5));  // back-right

  scene.add(car);

  // Controls setup
  const keys = { forward: false, backward: false, left: false, right: false, boost: false };

  document.addEventListener('keydown', e => {
    if (e.code === 'ArrowUp') keys.forward = true;
    if (e.code === 'ArrowDown') keys.backward = true;
    if (e.code === 'ArrowLeft') keys.left = true;
    if (e.code === 'ArrowRight') keys.right = true;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.boost = true;
  });

  document.addEventListener('keyup', e => {
    if (e.code === 'ArrowUp') keys.forward = false;
    if (e.code === 'ArrowDown') keys.backward = false;
    if (e.code === 'ArrowLeft') keys.left = false;
    if (e.code === 'ArrowRight') keys.right = false;
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') keys.boost = false;
  });

  let speed = 0;
  const baseMaxSpeed = 0.1;
  const boostMultiplier = 2;
  const acceleration = 0.002;
  const turnSpeed = 0.03;

  function animate() {
    requestAnimationFrame(animate);

    // Adjust max speed based on boost key
    const currentMaxSpeed = keys.boost ? baseMaxSpeed * boostMultiplier : baseMaxSpeed;

    // Accelerate / decelerate
    if (keys.forward) {
      speed += acceleration;
      if (speed > currentMaxSpeed) speed = currentMaxSpeed;
    } else if (keys.backward) {
      speed -= acceleration;
      if (speed < -currentMaxSpeed / 2) speed = -currentMaxSpeed / 2;
    } else {
      speed *= 0.95; // friction
    }

    // Steering only when moving
    if (speed !== 0) {
      if (keys.left) car.rotation.y += turnSpeed * (speed > 0 ? 1 : -1);
      if (keys.right) car.rotation.y -= turnSpeed * (speed > 0 ? 1 : -1);
    }

    // Move car forward in the direction itâ€™s facing
    car.position.x -= Math.sin(car.rotation.y) * speed;
    car.position.z -= Math.cos(car.rotation.y) * speed;

    // Camera follows car smoothly
    const relativeCameraOffset = new THREE.Vector3(0, 5, 10);
    const cameraOffset = relativeCameraOffset.applyMatrix4(car.matrixWorld);
    camera.position.lerp(cameraOffset, 0.1);
    camera.lookAt(car.position);

    renderer.render(scene, camera);
  }
  animate();

  // Handle browser resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
